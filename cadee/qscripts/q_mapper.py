#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
# MIT License
# 
# Copyright (c) 2016  Miha Purg <miha.purg@gmail.com>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
#
#
# Standalone script for running qfep5 on one or more directories (replicas).
# Run q_mapper.py with no arguments for info about arguments.
#
# It needs the names of the energy files in proper order (inside the file q_energyfiles.list)
# This file is automatically generated by q_genfeps.py when creating the inputs.
#
# Look at the __main__ function (or q_automapper.py) to see how the QMapper class 
# and its methods are used if you want to import them from your own script.
#
# Main function is q_map() (in QMapper). It iterates through the directories 
# (replicas), runs the q_mapsingle() function on each one (as a separate thread, 
# max number of  which is passed as an argument) which returns the qfep logfile if succesful or
# raises a QMappingError if notnd. q_map() then returns a QAnalyseMaps object (passing in the logfiles)
# and saves those that failed (exception in q_mapsingle). If all failed, it raises QMappingError.
#
# Other functions are:
# get_mapdirs()      - list of relative paths of the directories that are being mapped
# get_input_parms()  - a string representation of the mapping parameters used (hij,gs,bins,skip,T)
# get_failed()       - list of tuples ( "mapdir", "errorstring" )
# get_details()      - details of the mapping process
# set_hij()          - set Hij parameter (see q_automapper.py)
# set_gas_shift()    - set gas_shift parameter (see q_automapper.py)
#

import os
import sys
import threading
import time
import string
import subprocess
import q_analysemaps
from qscripts_config import QScriptsConfig as QScfg
from lib.common import backup_file, __version__

mapfile_template = string.Template(
"""${frames}         # number of files/frames
2  0                 # number of states and predefined off-diagonals
${kT}  ${skip}       # kT and number of points to skip
${bins}              # number of bins
${minpts_per_bin}    # minimum points for bin
${gas_shift}         # gas phase shift
1                    # number of diagonal elements
1 2 ${hij} 0 0 0     # states 1 and 2, A=const=Hij, mu=eta=r0= 0
1 -1                 # linear combination of states ( E = e1 - e2 )
${en_files}
stop""")


class QMappingError(Exception):
    pass

class _Mapthread(threading.Thread):
    def __init__(self, qmapperinstance, path):
        threading.Thread.__init__(self)
        self._qm = qmapperinstance    
        self.path = path
        self.error = None

    def run(self):
        try:
            self._qm.q_mapsingle( path=self.path ) 
            if self._qm._verbose:
                print "%s done." % os.path.relpath( self.path )
        except QMappingError as e:
            self.error = e
            if self._qm._verbose:
                print "%s FAILED." % os.path.relpath( self.path )

class QMapper(object):
    def __init__( self, hij, gas_shift, 
                  mapdirectories = [], # all subdirs OR cwd in case of no subdirs
                  en_list_fn = QScfg.get("files", "en_list_fn"),
                  bins = QScfg.get("mapping", "bin"),   
                  skip = QScfg.get("mapping", "skip"),
                  minpts_per_bin = QScfg.get("mapping", "minpts_per_bin"), 
                  temperature = QScfg.get("mapping", "temp"),
                  verbose = False,
                  nthreads = QScfg.get("mapping", "nthread") ):

        if (subprocess.call("type " + QScfg.get("qexec", "qfep"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) != 0):
            raise QMappingError("\nFatal! Executable '%s' not found." % QScfg.get("qexec", "qfep"))

        self._en_list_fn = en_list_fn
        self._frames = None      # set later in q_mapsingle
        self._verbose = verbose
        self._nthreads = nthreads
        
        if mapdirectories:
            for md in mapdirectories:
                if not os.path.lexists(md):
                    raise QMappingError("Directory %s does not exist!" % md)
        # if mapping directories were not passed in as an argument, store all directories in the current folder
        else:
            mapdirectories = sorted([ md for md in os.listdir( os.getcwd() ) if os.path.isdir(md) ])
            if self._verbose and mapdirectories:
                print "Will use these directories for mapping (use --mapdirs to change this):"
                print ", ".join(mapdirectories)
    
            # if there are no folders in the current working directory, map just the current one
            if not mapdirectories:
                mapdirectories = [ os.getcwd(), ]
                if self._verbose:
                    print "No subdirectories. Mapping files in current directory only."
        

        self._map_dirs = [ os.path.abspath(md) for md in mapdirectories ]
        self._map_parms = { "hij": hij,
                            "gas_shift": gas_shift,
                            "skip": skip,
                            "bins": bins,
                            "minpts_per_bin": minpts_per_bin,
                            "kT": float(temperature) * float(QScfg.get("mapping", "gas_const")),
                            "temperature": temperature }
        self._failed = []
        self._mapped = []

 
    def get_input_parms(self):
        return "q_mapper.py %s %s --nt %s --bin %s --skip %s --min %s --temp %s" % (self._map_parms["hij"],
                                                                                    self._map_parms["gas_shift"],
                                                                                    self._nthreads,
                                                                                    self._map_parms["bins"],
                                                                                    self._map_parms["skip"],
                                                                                    self._map_parms["minpts_per_bin"],
                                                                                    self._map_parms["temperature"])


    def get_mapdirs(self,relative_paths=False):
        if relative_paths:
            return [ os.path.relpath(md) for md in self._map_dirs ]
        else:
            return self._map_dirs

    def get_failed(self):
        return self._failed
 
    def get_details(self):
        # print the mapping parameters, folders, date, host, failed folders (to map) )
        if self._failed:
            fails = []
            for m,er in self._failed:
                fails.append( "%s -> %s" % (os.path.relpath(m), er) )
            fails = "\n".join(fails)
        else: fails = "None"

        details =    """
------------ QMapper details ------------
Date y-m-d and time: {date_time}
On this machine: {machine}
Mapped with q_mapper version: {version}
Number of energy files/frames: {frames}

Input parameters:
{inp_parms}

Actual command line input:
{act_inp}

Replicas failed to map:
{fails}
-----------------------------------------
""".format( date_time=time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime() ),
            machine=", ".join(os.uname()),
            version=__version__,
            frames=self._frames,
            inp_parms=self.get_input_parms(),
            act_inp=" ".join( sys.argv ),
            fails=fails )
            
        return details


    def set_hij(self, hij):
        self._map_parms["hij"] = hij

    def set_gas_shift(self, gas_shift):
        self._map_parms["gas_shift"] = gas_shift



    def q_map(self):
        # Creates threads that call q_mapsingle() on each directory (replica)
        # returns a tuple (mapped_directories, failed_directories)

        self._mapped = []
        self._failed = []

        trs = []
        for md in self._map_dirs:
            num = threading.activeCount() - 1     #    -1: one thread is the main thread
            while num == self._nthreads:
                time.sleep(0.3)
                num = threading.activeCount() - 1     # -1:    one thread is the main thread
            if num < self._nthreads:
                trs.append( _Mapthread(self, md) )
                trs[-1].start()
    
        # wait for threads to finish, save their response
        for t in trs:
            while t.isAlive():
                t.join(1.0)
            if t.error:
                self._failed.append( (t.path, t.error) )
            else:
                self._mapped.append( t.path )

        if not self._mapped:
            errstr=""
            for m,er in self._failed:
                errstr += "%s -> %s\n" % (os.path.relpath(m), er)
            raise QMappingError("All %s directories failed to map!\n%s" % ( len(self.get_mapdirs()), errstr) )

        return (self._mapped, self._failed)




    def q_mapsingle(self, path):
        # creates the input for qfep5 from the template and runs qfep5

        try:
            en_files = open(os.path.join(path, self._en_list_fn)).read()
        except IOError as e:
            raise QMappingError("Error when reading the file containing the energy filenames '%s': %s." % (self._en_list_fn, str(e)))

        if not en_files:
            raise QMappingError("q_enfiles.list is empty!")
        enfiles = [ en_file for en_file in en_files.split("\n") if en_file.strip() != "" ]

        frames=len(enfiles)
        if self._frames == None:
            self._frames=frames 
        elif self._frames != frames:   # this should never happen, but in case it does, something bad has happened...
            raise QMappingError("Not all replicas have the same number of frames! %d vs %d" % (self._frames, frames))

        for enf in enfiles:
            if not os.path.lexists( os.path.join(path, enf) ):
                raise QMappingError("Energy file '%s' missing" % enf)
            
        s = mapfile_template.substitute(en_files=en_files, frames=frames, **self._map_parms)
        
        # create input and output files and open them readwrite
        inpfn = os.path.join( path, QScfg.get("files", "qfep_inp") )
        outfn = os.path.join( path, QScfg.get("files", "qfep_out") )
        with open( inpfn, 'w+') as inpf:
            with open( outfn, 'w+') as outf:
                inpf.write(s)
                inpf.seek(0)    
                try:
                    p = subprocess.Popen( QScfg.get("qexec", "qfep"), stdin=inpf, stdout=outf, stderr=subprocess.PIPE, cwd=path)
                except OSError as e:
                    raise QMappingError("Problem when running qfep5: %s" % e )
                p.wait()
                err = p.stderr.read()
                if err:
                    raise QMappingError("qfep5 printed this to stderr: %s" % err)
    
        return outfn



if __name__ == "__main__":

    try:
        import argparse
    except ImportError:
        import lib.argparse as argparse
    
    parser = argparse.ArgumentParser()
    parser.add_argument('hij', type=float, help = 'Hij coupling constant')
    parser.add_argument('gas_shift', type=float, help = 'gas shift constant')
    parser.add_argument('--nt', dest='nthreads', type=int, help = 'Number of threads (default = %s)' % QScfg.get("mapping", "nthread"), default=QScfg.get("mapping", "nthread"))
    parser.add_argument('--bin', dest = 'bins', type=int, help = 'number of bins (default=%s)' % QScfg.get("mapping", "bin"), default=QScfg.get("mapping", "bin") )
    parser.add_argument('--skip', dest = 'skip', type=int, help = 'number of points to skip in each frame (default=%s)' % QScfg.get("mapping", "skip"), default=QScfg.get("mapping", "skip"))
    parser.add_argument('--min', dest = 'minpts_per_bin', type=int, help = 'minimum points for bin (default=%s)' % QScfg.get("mapping", "minpts_per_bin"), default=QScfg.get("mapping", "minpts_per_bin"))
    parser.add_argument('--temp', dest = 'temperature', type=float, help = 'Temperature (default=%s)' % QScfg.get("mapping", "temp"), default=QScfg.get("mapping", "temp"))
    parser.add_argument('--mapdirs', nargs="+", dest = 'mapdirs', help = 'Replica directories (default=all dirs in current folder) ', default=[])
    parser.add_argument('--logfile', dest = 'logfile', help = 'Logfile name (default=%s)' % QScfg.get("files", "mapper_logfile"), default=QScfg.get("files", "mapper_logfile"))

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    qmap_args = { "bins"             : args.bins,
                  "skip"             : args.skip,
                  "minpts_per_bin"   : args.minpts_per_bin,
                  "temperature"      : args.temperature,
                  "verbose"          : True,
                  "mapdirectories"   : args.mapdirs,
                  "nthreads"         : args.nthreads }

    try: 
        # create a QMapper instance by passing in all parameters
        qmap = QMapper( args.hij, args.gas_shift, **qmap_args )

        # perform the mapping
        (mapped, failed) = qmap.q_map()

        # analyse the maps
        qanalysemaps = q_analysemaps.QAnalyseMaps( mapped )

        # get the complete qmap summary and print it and write it to the logfile
        info = qmap.get_details()
        an_sum = qanalysemaps.get_summary()

        backup = backup_file(args.logfile)
        if backup:
            print "Backed up '%s' to '%s'" % (args.logfile, backup)

        with open(args.logfile, 'w') as logf:
            logf.write( info )
            logf.write( an_sum )

        print info
        print an_sum

    except QMappingError as e:
        print "Error while mapping: %s" % e
    except KeyboardInterrupt:
        print "\nCtrl-C detected. Quitting..."
        sys.exit(1)

